######
# Various, Useful R functions
######




#Functions below are incredibly useful but sometimes highly specific. 

















perm.creeper <-function(n = 999,  num = num, fst = creeper$fstHvL){
	#n = number of permutations 
	#num = number of SNPs to randomly select (use a vector)
	#fst is fst values from which to select
	#estimates perm likelihood of given SNP window generated by creeper script
	#draws SNPs within clusters to account for linkage effects
	
	vec=rep(0,n)
	for (i in 1:n){
		size = sample(num, 1, replace=TRUE)
		len = length(fst)-size
		samp = sample(c(1:len), 1, replace=T)
		ran = samp:(samp+size-1)
		x = mean(fst[ran])
		vec[i]=x
	}
	vec

}
		

norm.interval = function(data, variance = var(data), conf.level = 0.95) {
 z = qnorm((1 - conf.level)/2, lower.tail = FALSE)
 xbar = mean(data)
 sdx = sqrt(variance/length(data))
 c(xbar - z * sdx, xbar + z * sdx)
 }



cohens_d <- function(x, y) {
    lx <- length(x)- 1
    ly <- length(y)- 1
    md  <- abs(mean(x) - mean(y))        ## mean difference (numerator)
    csd <- lx * var(x) + ly * var(y)
    csd <- csd/(lx + ly)
    csd <- sqrt(csd)                     ## common sd computation

    cd  <- md/csd                        ## cohen's d
}




MultiWayOverlapper = function(win.start,win.end,gene.start,gene.end,gene.list) {
  #this is a monster, but basically, looks within each row for genes  overlapping with whatever you want
  blah=outer(as.numeric(unlist(win.start)), as.numeric(unlist(gene.end)), "<=") 
  blah1=outer(as.numeric(unlist(win.end)), as.numeric(unlist(gene.start)), ">=") 
  blah=(which(blah1=="TRUE" & blah=="TRUE", arr.ind=T)) #The gene region will be the colum variable
  if(!is.null(nrow(blah))){return(as.character(unlist(gene.list)[blah[,2]]))}	
  }

lenunique<-function(x){length(unique(x))}


write.list <- function(x,file,...){write.table(x,file,col.names=F,row.names=F,quote=F,...)}


Read.Fasta.DF <- function(data.frame){
#setwd("/media/data1/forty3/brock/AM45Regions")
r=readLines(data.frame);r=as.vector(r)
x=grep(">", r) #so, regions are from 2:19750
ma=x+1;mi=x-1;mi=mi[-1];mi=c(mi, length(r))
chrom=r[x];chrom=gsub(">", "", chrom)
chrom=gsub(" ","",chrom)
	seqs=c(0,1)
	for (i in 1:length(ma)){x=(r[ma[i]:mi[i]]);x=paste(x, collapse = '');seqs=c(seqs,x)}
	seqs=seqs[-c(1,2)]
	AMEL=data.frame(cbind(chrom, seqs))
	return(AMEL)
}


Write.Fasta.DF <- function(data.frame){
	#must have same format as Read.Fasta.DF output
		#col 1 = ID, col 2 = sequence
	seqs=as.character(unlist(data.frame[2]))
	ids=paste(">",as.character(unlist((data.frame[1]))),sep="")
	for (i in 1:nrow(data.frame)){
		sink(file="out.fa", append=T)
		cat(as.character(ids[i]));cat("\n")
		cat(seqs[i]);cat("\n")	
		sink()
	}
}


GC.content <- function(x){
#taxes in a string (fasta format), outputs GC
length(unlist(strsplit(x,""))[unlist(strsplit(x,"")) %in% c("G", "C")])/length(unlist(strsplit(x,"")))
}



#False Discovery Rate (B-H correction)
FDRate=function (pvec, rate) {
    pord <- sort(pvec)
    np <- length(pord)
    maxp <- tail(pord, 1)
    medp <- pord[round(np/2)]
    D <- (np/2)/(maxp - medp)
    ivec <- 1:np
    b <- rate < D * pord/ivec
    nb <- sum(b)
    if (nb == 0) {
        p <- maxp
    }
    else {
        if (nb == np) {
            p <- 0
        }
        else {
            p <- pord[match(TRUE, b) - 1]
        }
    }
    
}

FDRcontrol<-function(pvec,FDR=0.05){
# use the Simes/Benjamini/Hochberg method to choose which of a list of p values satifies a given FDR
s<-sort(pvec, index.return=TRUE); p<-s$x; n<-length(p); ivec<-1:n
b<-p<=FDR*ivec/n; i<-max(c(0,ivec[b]))
b<-ivec<=i
b<-b[(sort(s$ix, index.return=TRUE))$ix]
b
}


#Reverse complement a fasta file
rev.comp<-function(x,rev=TRUE)
{
x<-toupper(x)
y<-rep("N",nchar(x))
xx<-unlist(strsplit(x,NULL))
for (bbb in 1:nchar(x))
    {
        if(xx[bbb]=="A") y[bbb]<-"T"    
        if(xx[bbb]=="C") y[bbb]<-"G"    
        if(xx[bbb]=="G") y[bbb]<-"C"    
        if(xx[bbb]=="T") y[bbb]<-"A"
    }
if(rev==FALSE) 
    {
    for(ccc in (1:nchar(x)))
        {
        if(ccc==1) yy<-y[ccc] else yy<-paste(yy,y[ccc],sep="")
        }
    }
if(rev==T)
    {
    zz<-rep(NA,nchar(x))
    for(ccc in (1:nchar(x)))
        {
        zz[ccc]<-y[nchar(x)+1-ccc]
        if(ccc==1) yy<-zz[ccc] else yy<-paste(yy,zz[ccc],sep="")
        }
    }
    return(as.character(yy))  
} 
 
#Fabio Marroni's rev comp function (thanks) 











